use std::ffi::OsStr;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 推荐下面的方式生成grpc rust代码
    // 1.读取protos目录下的*.proto
    let proto_dir: PathBuf = "protos".into(); // proto文件所在目录
    let mut file_list = Vec::new(); // 需要读取的proto文件列表
    let lists = proto_dir.read_dir().expect("failed to read proto dir");
    for entry_path in lists {
        if entry_path.as_ref().unwrap().path().is_file() {
            file_list.push(entry_path.unwrap().path())
        }
    }

    // 2.删除原来的src目录，可以根据实际情况看是否需要删除
    let out_dir = Path::new("src"); // 存放grpc rust pb代码生成的目录
    let _ = fs::remove_dir_all(out_dir);
    let _ = fs::create_dir(out_dir);

    // grpc reflection 描述信息这是一个二进制文件
    // let descriptor_path = out_dir.join("rpc_descriptor.bin");

    // 3.生成rust grpc代码，需要指定 rust grpc pb代码生成的目录
    tonic_prost_build::configure()
        // .file_descriptor_set_path(&descriptor_path)
        .out_dir(out_dir)
        .compile_protos(&file_list, &[proto_dir])?;

    // 4.读取src下面生成好的rust文件，并将模块名字写入lib.rs文件中
    // 也就是说，将文件名字作为模块名字，格式：pub mod xxx;
    // 这里需要先清空src/lib.rs文件内容
    let mod_filename = out_dir.join("lib.rs");
    let _ = fs::remove_file(&mod_filename); // 可根据实际情况，看是否需要删除
    let mut mod_file = fs::OpenOptions::new()
        .write(true)
        .create(true)
        .open(&mod_filename)
        .expect("failed to create lib.rs");

    // header是生成的rust文件头提示说明
    let header = String::from("// This file is @generated by prost-build. DO NOT EDIT.\n");
    let _ = mod_file.write(header.as_bytes());

    // 先读取src中的文件，然后将模块名字写入lib.rs文件中
    let ext: Option<&OsStr> = Some(&OsStr::new("rs")); // rust文件拓展名，不包含点
    let lists = out_dir.read_dir().expect("failed to read src dir");
    for entry_path in lists {
        if entry_path.as_ref().unwrap().path().is_file() {
            let path = entry_path.unwrap().path();
            if path.extension().eq(&ext) {
                let file = path.file_name().unwrap_or(OsStr::new(""));
                let filename = file.to_str().unwrap();
                if filename.contains("google.api") {
                    // 跳过google.api.rs这样的文件
                    fs::remove_file(out_dir.join(filename))?;
                    continue;
                }
                if filename == "lib.rs" {
                    // 跳过lib.rs文件
                    continue;
                }

                // 获取文件名，不包含拓展名，并将模块名字写入lib.rs中
                let module = filename.replace(".rs", "");
                mod_file
                    .write(format!("pub mod {};\n", module).as_bytes())
                    .expect("failed to write to lib.rs");

                // 为生成的message实现 serde encode/decode 功能
                let filename = out_dir.join(filename);
                let mut buffer = fs::read_to_string(&filename).unwrap();
                buffer = buffer.replace(
                    "prost::Message",
                    "prost::Message, serde::Serialize, serde::Deserialize",
                );
                fs::write(&filename, buffer).expect("failed to write file content");
            }
        }
    }

    Ok(())
}
